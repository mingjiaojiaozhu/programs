* 0.数学
  * 0.素数筛选法
    * [0.Eratosthenes筛选法](math/EratosthenesSieve.cpp)
    * [1.Euler筛](math/EulerSieve.cpp)
  * [1.Euclidean算法(GCD&LCM)](math/Euclidean.cpp)
  * [2.扩展Euclidean算法](math/ExtendedEuclidean.cpp)
  * [3.中国剩余定理(CRT)](math/CRT.cpp)
  * [4.Euler函数](math/EulerTotientFunction.cpp)
  * [5.Rabin-Miller大素数判定](math/RabinMiller.cpp)
  * [6.Pollard-rho大数因式分解](math/PollardRho.cpp)
* 1.数据结构
  * 0.线形结构
    * [0.数组](structure/linear/Array.cpp)
    * 1.链表
      * [0.单链表](structure/linear/linked_list/SinglyLinkedList.cpp)
      * [1.双链表](structure/linear/linked_list/DoublyLinkedList.cpp)
      * [2.跳表](structure/linear/linked_list/SkipList.cpp)
      * [3.环形链表](structure/linear/linked_list/CircularLinkedList.cpp)
    * 2.栈
      * [0.基于数组](structure/linear/stack/StackOfArray.cpp)
      * [1.基于链表](structure/linear/stack/StackOfLinkedList.cpp)
    * 3.队列
      * 0.单向队列
        * [0.基于数组](structure/linear/queue/QueueOfArray.cpp)
        * [1.基于链表](structure/linear/queue/QueueOfLinkedList.cpp)
      * 1.双向队列
        * [0.基于数组](structure/linear/queue/DequeOfArray.cpp)
        * [1.基于链表](structure/linear/queue/DequeOfLinkedList.cpp)
      * [2.优先队列](structure/linear/queue/PriorityQueue.cpp)
  * 1.树形结构
    * [0.二叉树](structure/tree/binary_tree/BinaryTree.cpp)
      * 0.遍历
        * [0.前序遍历](structure/tree/binary_tree/traversal/PreOrderTraversal.cpp)
          * [0.Morris](structure/tree/binary_tree/traversal/morris/PreOrderTraversal.cpp)
        * [1.中序遍历](structure/tree/binary_tree/traversal/InOrderTraversal.cpp)
          * [0.Morris](structure/tree/binary_tree/traversal/morris/InOrderTraversal.cpp)
        * [2.后序遍历](structure/tree/binary_tree/traversal/PostOrderTraversal.cpp)
          * [0.Morris](structure/tree/binary_tree/traversal/morris/PostOrderTraversal.cpp)
        * [3.层序遍历](structure/tree/binary_tree/traversal/LevelOrderTraversal.cpp)
      * 1.重建
        * [0.基于前序和中序遍历](structure/tree/binary_tree/rebuild/RebuildOfPreAndInOrder.cpp)
        * [0.基于中序和后序遍历](structure/tree/binary_tree/rebuild/RebuildOfInAndPostOrder.cpp)
    * 1.检索树
      * [0.二叉检索树](structure/tree/search_tree/BinarySearchTree.cpp)
      * [1.树堆](structure/tree/search_tree/Treap.cpp)
      * [2.伸展树](structure/tree/search_tree/SplayTree.cpp)
      * [3.平衡二叉树(AVL)](structure/tree/search_tree/AVLTree.cpp)
      * [4.红黑树](structure/tree/search_tree/RedBlackTree.cpp)
      * [5.B树](structure/tree/search_tree/BTree.cpp)
      * [6.B+树](structure/tree/search_tree/BPlusTree.cpp)
    * [2.字典树](structure/tree/TrieTree.cpp)
    * [3.线段树](structure/tree/SegmentTree.cpp)
    * 4.堆
      * [0.二叉堆](structure/tree/heap/BinaryHeap.cpp)
      * [1.二项堆](structure/tree/heap/BinomialHeap.cpp)
      * [2.Fibonacci堆](structure/tree/heap/FibonacciHeap.cpp)
      * [3.配对堆](structure/tree/heap/PairingHeap.cpp)
  * 2.图形结构
    * [0.邻接矩阵](structure/graph/GraphOfAdjacencyMatrix.cpp)
    * [1.邻接表](structure/graph/GraphOfAdjacencyList.cpp)
  * 3.集合结构
    * 0.散列表
      * [0.开放地址法](structure/set/hash/HashOfOpenAddress.cpp)
      * [1.链地址法](structure/set/hash/HashOfChainAddress.cpp)
    * [1.LRU缓存](structure/set/LRUCache.cpp)
    * [2.位图](structure/set/BitMap.cpp)
    * [3.Bloom过滤器](structure/set/BloomFilter.cpp)
    * [4.并查集](structure/set/UnionFind.cpp)
* 2.排序
  * 0.数组
    * [0.冒泡排序](sort/array/BubbleSort.cpp)
    * [1.选择排序](sort/array/SelectionSort.cpp)
    * [2.插入排序](sort/array/InsertionSort.cpp)
    * [3.Shell排序](sort/array/ShellSort.cpp)
    * [4.堆排序](sort/array/HeapSort.cpp)
    * [5.快速排序](sort/array/QuickSort.cpp)
    * [6.归并排序](sort/array/MergeSort.cpp)
    * [7.计数排序](sort/array/CountingSort.cpp)
    * [8.桶排序](sort/array/BucketSort.cpp)
    * [9.基数排序](sort/array/RadixSort.cpp)
    * [A.完美排序](sort/array/StoogeSort.cpp)
    * [B.鸡尾酒排序](sort/array/CocktailSort.cpp)
    * [C.地精排序](sort/array/GnomeSort.cpp)
    * [D.原地归并排序](sort/array/MergeInPlaceSort.cpp)
    * [E.煎饼排序](sort/array/PancakeSort.cpp)
    * [F.Tim排序](sort/array/TimSort.cpp)
  * 1.链表
    * [0.冒泡排序](sort/linked_list/BubbleSort.cpp)
    * [1.选择排序](sort/linked_list/SelectionSort.cpp)
    * [2.插入排序](sort/linked_list/InsertionSort.cpp)
    * [3.快速排序](sort/linked_list/QuickSort.cpp)
    * [4.归并排序](sort/linked_list/MergeSort.cpp)
    * [5.基数排序](sort/linked_list/RadixSort.cpp)
  * 2.字符串
    * [0.LSD基数排序](sort/string/LSDRadixSort.cpp)
    * [1.MSD基数排序](sort/string/MSDRadixSort.cpp)
    * [2.快速排序](sort/string/QuickSort.cpp)
  * [3.外部排序](sort/ExternalSort.cpp)
  * 4.随机排序(洗牌算法)
    * [0.Fisher-Yates](sort/shuffle/FisherYates.cpp)
    * [1.Knuth-Durstenfeld](sort/shuffle/KnuthDurstenfeld.cpp)
    * [2.Inside-Out](sort/shuffle/InsideOut.cpp)
* 3.查找
  * 0.数组
    * [0.顺序查找](search/array/SequenceSearch.cpp)
    * [1.二分法查找](search/array/BinarySearch.cpp)
    * [2.插值查找](search/array/InterpolationSearch.cpp)
    * [3.Fibonacci查找](search/array/FibonacciSearch.cpp)
    * [4.跳跃查找](search/array/JumpSearch.cpp)
    * [5.分块查找](search/array/BlockingSearch.cpp)
  * 1.链表
    * [0.顺序查找](search/linked_list/SequenceSearch.cpp)
    * [1.二分法查找](search/linked_list/BinarySearch.cpp)
  * 2.字符串
    * [0.Brute-Force(BF)](search/string/BruteForce.cpp)
    * [1.Rabin-Karp(RK)](search/string/RabinKarp.cpp)
    * [2.Knuth-Morris-Pratt(KMP)](search/string/KnuthMorrisPratt.cpp)
    * [3.Boyer-Moore(BM)](search/string/BoyerMoore.cpp)
    * [4.Sunday](search/string/Sunday.cpp)
    * [5.Horspool](search/string/Horspool.cpp)
    * [6.Aho-Corasick(AC自动机)](search/string/AhoCorasick.cpp)
  * 3.top k
    * [0.堆选择](search/top_k/HeapSelect.cpp)
    * [1.随机选择](search/top_k/QuickSelect.cpp)
    * [2.线性时间选择(BFPRT)](search/top_k/BFPRTSelect.cpp)
* 4.图
  * 0.遍历
    * [0.深度优先遍历(DFS)](graph/traversal/DFS.cpp)
    * [1.广度优先遍历(BFS)](graph/traversal/BFS.cpp)
  * 1.最短路径
    * [0.Dijkstra](graph/shortest_path/Dijkstra.cpp)
    * [1.Bellman-Ford(BF)](graph/shortest_path/BellmanFord.cpp)
    * [2.最短路径快速算法(SPFA)](graph/shortest_path/SPFA.cpp)
    * [3.Floyd-Warshall](graph/shortest_path/FloydWarshall.cpp)
    * [4.Johnson](graph/shortest_path/Johnson.cpp)
    * [5.A*](graph/shortest_path/AStar.cpp)
  * 2.最小生成树
    * [0.Prim](graph/minimum_spanning_tree/Prim.cpp)
    * [1.Kruskal](graph/minimum_spanning_tree/Kruskal.cpp)
    * [2.Boruvka](graph/minimum_spanning_tree/Boruvka.cpp)
  * 3.强连通分量
    * [0.Kosaraju-Sharir](graph/strongly_connected_component/KosarajuSharir.cpp)
    * [1.Tarjan](graph/strongly_connected_component/Tarjan.cpp)
    * [2.Gabow](graph/strongly_connected_component/Gabow.cpp)
  * [4.拓扑排序](graph/topological_sort/TopologicalSort.cpp)
    * [0.Kahn](graph/topological_sort/Kahn.cpp)
  * [5.关键路径](graph/CriticalPath.cpp)
  * 6.Euler路径
    * [0.无向图](graph/eulerian_path/undirected/EulerianPath.cpp)
      * [0.Fleury](graph/eulerian_path/undirected/Fleury.cpp)
      * [1.Hierholzer](graph/eulerian_path/undirected/Hierholzer.cpp)
    * [1.有向图](graph/eulerian_path/directed/EulerianPath.cpp)
      * [0.Fleury](graph/eulerian_path/directed/Fleury.cpp)
      * [1.Hierholzer](graph/eulerian_path/directed/Hierholzer.cpp)
  * 7.最大流
    * [0.Ford-Fulkerson(FFA)](graph/maximum_flow/FordFulkerson.cpp)
    * [1.Edmonds-Karp(EK)](graph/maximum_flow/EdmondsKarp.cpp)
    * [2.Dinic](graph/maximum_flow/Dinic.cpp)
    * [3.最短增广路(SAP)](graph/maximum_flow/SAP.cpp)
    * [4.最高标号预流推进(HLPP)](graph/maximum_flow/HLPP.cpp)
  * 8.最小费用最大流
    * [0.Dijkstra](graph/minimum_cost_maximum_flow/Dijkstra.cpp)
    * [1.Bellman-Ford(BF)](graph/minimum_cost_maximum_flow/BellmanFord.cpp)
    * [2.最短路径快速算法(SPFA)](graph/minimum_cost_maximum_flow/SPFA.cpp)
    * [3.Dinic](graph/minimum_cost_maximum_flow/Dinic.cpp)
  * 9.最大匹配
    * [0.匈牙利算法](graph/maximum_matching/Hungary.cpp)
    * [1.Kuhn-Munkres(KM)](graph/maximum_matching/KuhnMunkres.cpp)
* 5.五大经典算法
  * 0.分治法
    * [0.Karatsuba乘法](classic/divide_and_conquer/Karatsuba.cpp)
    * [1.Strassen矩阵乘法](classic/divide_and_conquer/Strassen.cpp)
    * [2.棋盘覆盖问题](classic/divide_and_conquer/ChessboardCoverage.cpp)
    * [3.最近点对问题](classic/divide_and_conquer/ClosestPairOfPoints.cpp)
    * [4.循环赛日程表](classic/divide_and_conquer/RoundRobinSchedule.cpp)
    * [5.Hanoi塔](classic/divide_and_conquer/Hanoi.cpp)
  * 1.动态规划
    * [0.Fibonacci数列](classic/dynamic_programming/FibonacciSequence.cpp)
    * 1.背包问题
      * [0.0-1背包问题](classic/dynamic_programming/KnapsackOfZeroOne.cpp)
      * [1.完全背包问题](classic/dynamic_programming/KnapsackOfComplete.cpp)
      * [2.多重背包问题](classic/dynamic_programming/KnapsackOfMultiple.cpp)
    * [2.零钱兑换问题](classic/dynamic_programming/CoinChange.cpp)
    * [3.最长上升子序列(LIS)](classic/dynamic_programming/LongestIncreasingSubsequence.cpp)
    * [4.最长公共子序列(LCS)](classic/dynamic_programming/LongestCommonSubsequence.cpp)
    * [5.最长公共子串](classic/dynamic_programming/LongestCommonSubstring.cpp)
    * [6.最长回文子串](classic/dynamic_programming/LongestPalindromicSubstring.cpp)
    * [7.Levenshtein距离](classic/dynamic_programming/LevenshteinDistance.cpp)
  * 2.贪心算法
    * [0.Huffman编码](classic/greedy_algorithm/HuffmanCoding.cpp)
    * [1.部分背包问题](classic/greedy_algorithm/KnapsackOfFractional.cpp)
    * [2.活动安排问题](classic/greedy_algorithm/ActivitySelection.cpp)
    * [3.区间覆盖问题](classic/greedy_algorithm/IntervalCoverage.cpp)
  * 3.回溯法
    * 0.排列组合
      * [0.排列](classic/back_tracking/Arrangement.cpp)
      * [1.组合](classic/back_tracking/Combination.cpp)
      * [2.子集](classic/back_tracking/Subcollection.cpp)
    * [1.八皇后问题](classic/back_tracking/EightQueens.cpp)
    * [2.批处理作业调度问题](classic/back_tracking/BatchJobsScheduling.cpp)
    * [3.连续邮资问题](classic/back_tracking/ContinuousPostage.cpp)
    * [4.数独](classic/back_tracking/Sudoku.cpp)
  * 4.分支限界法
    * [0.最优装载问题](classic/branch_and_bound/OptimalLoading.cpp)
* 6.其他
  * [0.大数加减乘除](other/BigInteger.cpp)
  * [1.Josephus环](other/JosephusRing.cpp)
  * [2.逆波兰式(RPN)](other/RPN.cpp)
  * [3.Manacher](other/Manacher.cpp)
  * [4.雪花算法](other/SnowFlake.cpp)
  * [5.坐标系转换(WGS84&GCJ-02&BD09)](other/GPSConverter.cpp)